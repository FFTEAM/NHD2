diff --git a/glcddrivers/Makefile b/glcddrivers/Makefile
index 9f70592..5efdff7 100644
--- a/glcddrivers/Makefile
+++ b/glcddrivers/Makefile
@@ -26,6 +26,8 @@ DEFINES += -DHAVE_LIBHID
 endif
 
 
+OBJS += vuduo2lcd.o
+
 ifeq ($(shell pkg-config --exists libusb && echo 1), 1)
     DEFINES += -DHAVE_LIBUSB
     ifdef HAVE_DRIVER_AX206DPF
diff --git a/glcddrivers/drivers.c b/glcddrivers/drivers.c
index e720c0e..934f307 100644
--- a/glcddrivers/drivers.c
+++ b/glcddrivers/drivers.c
@@ -30,6 +30,7 @@
 #include "dm140gink.h"
 #include "serdisp.h"
 #include "g15daemon.h"
+#include "vuduo2lcd.h"
 #ifdef HAVE_DRIVER_AX206DPF
 #include "ax206dpf.h"
 #endif
@@ -63,6 +64,7 @@ tDriver drivers[] =
     {"dm140gink",     kDriverDM140GINK},
     {"serdisp",       kDriverSerDisp},
     {"g15daemon",     kDriverG15daemon},
+    {"vuduo2lcd",     kDriverVUDUO2LCD},
 #ifdef HAVE_DRIVER_AX206DPF
     {"ax206dpf",      kDriverAX206DPF},
 #endif    
@@ -130,6 +132,8 @@ cDriver * CreateDriver(int driverID, cDriverConfig * config)
             return new cDriverSerDisp(config);
         case kDriverG15daemon:
             return new cDriverG15daemon(config);
+        case kDriverVUDUO2LCD:
+            return new cDriverVUDUO2LCD(config);
 #ifdef HAVE_DRIVER_AX206DPF
         case kDriverAX206DPF:
             return new cDriverAX206DPF(config);
diff --git a/glcddrivers/drivers.h b/glcddrivers/drivers.h
index 3968e81..7eb297e 100644
--- a/glcddrivers/drivers.h
+++ b/glcddrivers/drivers.h
@@ -49,6 +49,7 @@ enum eDriver
 #ifdef HAVE_DRIVER_VNCSERVER
     kDriverVncServer     = 19,
 #endif    
+    kDriverVUDUO2LCD     = 50,
     kDriverSerDisp       = 100,
     kDriverG15daemon     = 200
 };
diff -urN a/glcddrivers/vuduo2lcd.c b/glcddrivers/vuduo2lcd.c
--- a/glcddrivers/vuduo2lcd.c	1970-01-01 00:00:00.000000000 +0000
+++ b/glcddrivers/vuduo2lcd.c	2013-07-14 04:10:16.000000000 +0000
@@ -0,0 +1,186 @@
+/*
+ * GraphLCD driver library
+ *
+ * vuduo2lcd.c  -  Vu+ Duo2 output device
+ *             Output goes to Vu+ Duo2 internal LCD.
+ *
+ * This file is released under the GNU General Public License. Refer
+ * to the COPYING file distributed with this package.
+ *
+ * (c) 2004-2010 Andreas Regel <andreas.regel AT powarman.de>
+ * (c) 2010-2011 Wolfgang Astleitner <mrwastl AT users sourceforge net>
+                 Andreas 'randy' Weinberger 
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <syslog.h>
+#include <cstring>
+
+#include "common.h"
+#include "config.h"
+#include "vuduo2lcd.h"
+
+
+namespace GLCD
+{
+
+cDriverVUDUO2LCD::cDriverVUDUO2LCD(cDriverConfig * config)
+:   cDriver(config),
+    lcdfd(-1)
+{
+}
+
+cDriverVUDUO2LCD::~cDriverVUDUO2LCD()
+{
+    DeInit();
+}
+
+int cDriverVUDUO2LCD::Init()
+{
+    width = config->width;
+    if (width <= 0)
+        width = 400;
+    height = config->height;
+    if (height <= 0)
+        height = 240;
+
+    for (unsigned int i = 0; i < config->options.size(); i++)
+    {
+        if (config->options[i].name == "")
+        {
+        }
+    }
+
+    newLCD = new uint16_t[width * height];
+    if (newLCD)
+        memset(newLCD, 0, width * height);
+    oldLCD = new uint16_t[width * height];
+    if (oldLCD)
+        memset(oldLCD, 0, width * height);
+
+    if (config->device == "")
+    {
+        lcdfd = open("/dev/lcd2", O_RDWR);
+    }
+    else
+    {
+        lcdfd = open(config->device.c_str(), O_RDWR);
+    }
+    
+    //lcdfd = open("/dev/lcd2", O_RDWR);
+    if (lcdfd < 0)
+    {
+        syslog(LOG_ERR, "%s: cannot open vuduo2 lcd device.\n", config->name.c_str());
+        return -1;
+    }
+    syslog(LOG_INFO, "%s: The vuduo2 lcd device was opened successfully.\n", config->name.c_str());
+
+    *oldConfig = *config;
+
+    // clear display
+    Clear();
+
+    syslog(LOG_INFO, "%s: vuduo2 lcd driver initialized.\n", config->name.c_str());
+    return 0;
+}
+
+int cDriverVUDUO2LCD::DeInit()
+{
+    if (newLCD)
+    {
+        delete[] newLCD;
+        newLCD = 0;
+    }
+    if (oldLCD)
+    {
+        delete[] oldLCD;
+        oldLCD = 0;
+    }
+    if (-1 != lcdfd)
+        close(lcdfd);
+    return 0;
+}
+
+int cDriverVUDUO2LCD::CheckSetup()
+{
+    if (config->width != oldConfig->width ||
+        config->height != oldConfig->height)
+    {
+        DeInit();
+        Init();
+        return 0;
+    }
+
+    if (config->upsideDown != oldConfig->upsideDown ||
+        config->invert != oldConfig->invert)
+    {
+        oldConfig->upsideDown = config->upsideDown;
+        oldConfig->invert = config->invert;
+        return 1;
+    }
+    return 0;
+}
+
+void cDriverVUDUO2LCD::Clear()
+{
+    memset(newLCD, 0, width * height);
+}
+
+void cDriverVUDUO2LCD::SetPixel(int x, int y, uint32_t data)
+{
+    if (x >= width || y >= height)
+        return;
+
+    uint32_t pix = ((data & 0x00FF0000) >> 16) | (data & 0x0000FF00) | ((data & 0x000000FF) << 16);
+    //newLCD[y * width + x] = pix;
+
+    unsigned char* row_pointers_bit_shift = (unsigned char*) &newLCD[0];
+    unsigned char* row_pointers_i = (unsigned char*) &pix;
+    int row_pointers_2_ptr = (y * width + x) * 2;
+    int j = 0;
+    row_pointers_bit_shift[row_pointers_2_ptr+0]=(row_pointers_i[j]&248)|(row_pointers_i[j+1]>>5);
+    row_pointers_bit_shift[row_pointers_2_ptr+1]=((row_pointers_i[j+1]&28)<<3)|(row_pointers_i[j+2]>>3);
+}
+
+void cDriverVUDUO2LCD::Refresh(bool refreshAll)
+{
+    int i;
+    bool refresh;
+    char fileName[256];
+    char str[32];
+    FILE * fp;
+    unsigned char c;
+
+    refresh = false;
+    if (CheckSetup() > 0)
+        refresh = true;
+
+    for (i = 0; i < width * height; i++)
+    {
+        if (newLCD[i] != oldLCD[i])
+        {
+            refresh = true;
+            break;
+        }
+    }
+
+    if (refresh)
+    {
+        for (i = 0; i < width * height; i++)
+        {
+            oldLCD[i] = newLCD[i];
+        }
+        unsigned char* row_pointers_bit_shift = (unsigned char*) &newLCD[0];
+	{
+		int w=-1;
+		w = write(lcdfd, row_pointers_bit_shift, height * width * 2);
+		printf("write ret : %d\n",w);
+//		ret = ioctl(lcdfd, 0);
+		printf("write to /dev/lcd2 : %d\n",w);
+	}
+    }
+}
+
+} // end of namespace
diff -urN a/glcddrivers/vuduo2lcd.h b/glcddrivers/vuduo2lcd.h
--- a/glcddrivers/vuduo2lcd.h	1970-01-01 00:00:00.000000000 +0000
+++ b/glcddrivers/vuduo2lcd.h	2013-07-14 03:22:12.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+ * GraphLCD driver library
+ *
+ * vuduo2lcd.h  -  Vu+ Duo2 output device
+ *             Output goes to Vu+ Duo2 internal LCD.
+ *
+ * This file is released under the GNU General Public License. Refer
+ * to the COPYING file distributed with this package.
+ *
+ * (c) 2004-2010 Andreas Regel <andreas.regel AT powarman.de>
+ * (c) 2010-2011 Wolfgang Astleitner <mrwastl AT users sourceforge net>
+                 Andreas 'randy' Weinberger 
+ */
+
+#ifndef _GLCDDRIVERS_VUDUO2LCD_H_
+#define _GLCDDRIVERS_VUDUO2LCD_H_
+
+#include "driver.h"
+
+
+namespace GLCD
+{
+
+class cDriverConfig;
+
+class cDriverVUDUO2LCD : public cDriver
+{
+private:
+    int lcdfd;
+    uint16_t * newLCD;
+    uint16_t * oldLCD;
+
+    int CheckSetup();
+
+public:
+    cDriverVUDUO2LCD(cDriverConfig * config);
+    virtual ~cDriverVUDUO2LCD();
+
+    virtual int Init();
+    virtual int DeInit();
+
+    virtual void Clear();
+    virtual void SetPixel(int x, int y, uint32_t data);
+    //virtual void Set8Pixels(int x, int y, unsigned char data);
+    virtual void Refresh(bool refreshAll = false);
+};
+
+} // end of namespace
+
+#endif
